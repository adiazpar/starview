/**
 * useMapMarkers Hook
 *
 * Fetches GeoJSON FeatureCollection pre-generated by the backend.
 * Loads the FULL dataset on mount - Mapbox handles viewport culling natively.
 * Uses React Query for caching (matches backend 30min cache for full data).
 * Provides O(1) marker lookup via markerMap built from features.
 *
 * Architecture Note:
 * We intentionally do NOT use bbox-based loading because:
 * 1. Backend only caches the full dataset (no bbox = 30min cache hit)
 * 2. Any bbox query bypasses the cache and hits the database
 * 3. Mapbox GL JS already culls features outside viewport for rendering
 * 4. One API call on mount is better than N calls per pan session
 */

import { useMemo } from 'react';
import { useQuery, keepPreviousData } from '@tanstack/react-query';
import { locationsApi } from '../services/locations';

// Empty GeoJSON to avoid null checks
const EMPTY_GEOJSON = { type: 'FeatureCollection', features: [] };

/**
 * Parse GeoJSON properties that may be JSON strings
 * Mapbox/GeoJSON can serialize objects/arrays as strings
 * Exported for use in click handlers when marker isn't in current markerMap
 */
export function parseGeoJSONProperties(props) {
  return {
    ...props,
    images: typeof props.images === 'string' ? JSON.parse(props.images) : (props.images || []),
    type_metadata: typeof props.type_metadata === 'string' ? JSON.parse(props.type_metadata) : (props.type_metadata || {}),
  };
}

/**
 * Fetch map GeoJSON for locations
 * @param {Object} options - Hook options
 * @param {Object} options.filters - Filter params from useExploreFilters.apiParams
 * @param {boolean} options.enabled - Whether to enable the query (default: true)
 * @returns {Object} Query result with GeoJSON and lookup map
 */
export function useMapMarkers({ filters = {}, enabled = true } = {}) {
  // Check if filters are active (for cache timing)
  const hasFilters = Object.keys(filters).length > 0;

  // Stable filter key - stringify to prevent cache misses when object reference changes
  const filterKey = useMemo(() => JSON.stringify(filters), [filters]);

  const query = useQuery({
    // Simple query key - no bbox fragmentation
    // Full dataset uses one cache entry; filtered queries use filter-specific entries
    queryKey: ['mapGeoJSON', 'filters', filterKey],
    queryFn: async () => {
      // Never send bbox - load full dataset and let Mapbox handle viewport culling
      const response = await locationsApi.getMapGeoJSON(filters);
      return response.data;
    },
    // Full unfiltered dataset cached 30 min (matches backend cache)
    // Filtered queries cached 5 min (backend doesn't cache these)
    staleTime: hasFilters ? 5 * 60 * 1000 : 30 * 60 * 1000,
    // Keep previous data while new query loads - prevents empty markerMap during loading
    placeholderData: keepPreviousData,
    enabled,
  });

  const geojson = query.data || EMPTY_GEOJSON;

  // O(1) lookup map for marker properties by ID
  // Maps feature.properties.id -> parsed properties (with images/type_metadata as objects)
  const markerMap = useMemo(() => {
    if (!geojson.features) return new Map();
    return new Map(geojson.features.map((f) => [f.properties.id, parseGeoJSONProperties(f.properties)]));
  }, [geojson]);

  // For backwards compatibility, expose markers array
  // (some components may still use markers.length, etc.)
  const markers = useMemo(() => {
    if (!geojson.features) return [];
    return geojson.features.map((f) => {
      const parsed = parseGeoJSONProperties(f.properties);
      return {
        ...parsed,
        // Coordinates are in properties now, but also keep from geometry for safety
        latitude: parsed.latitude ?? f.geometry.coordinates[1],
        longitude: parsed.longitude ?? f.geometry.coordinates[0],
      };
    });
  }, [geojson]);

  return {
    geojson, // GeoJSON FeatureCollection ready for Mapbox
    markers, // Backwards compatible markers array
    markerMap, // Use markerMap.get(id) for O(1) lookup
    isLoading: query.isLoading,
    isError: query.isError,
    error: query.error,
    refetch: query.refetch,
  };
}

export default useMapMarkers;
