/**
 * useMapMarkers Hook
 *
 * Fetches GeoJSON FeatureCollection pre-generated by the backend.
 * Supports viewport-based loading via bbox parameter.
 * Uses React Query for caching (matches backend 30min cache for full data).
 * Provides O(1) marker lookup via markerMap built from features.
 */

import { useMemo } from 'react';
import { useQuery, keepPreviousData } from '@tanstack/react-query';
import { locationsApi } from '../services/locations';

// Empty GeoJSON to avoid null checks
const EMPTY_GEOJSON = { type: 'FeatureCollection', features: [] };

/**
 * Parse GeoJSON properties that may be JSON strings
 * Mapbox/GeoJSON can serialize objects/arrays as strings
 * Exported for use in click handlers when marker isn't in current markerMap
 */
export function parseGeoJSONProperties(props) {
  return {
    ...props,
    images: typeof props.images === 'string' ? JSON.parse(props.images) : (props.images || []),
    type_metadata: typeof props.type_metadata === 'string' ? JSON.parse(props.type_metadata) : (props.type_metadata || {}),
  };
}

/**
 * Convert bounds object to bbox string for API
 * @param {Object} bounds - { west, south, east, north }
 * @returns {string} - "west,south,east,north"
 */
function boundsToBbox(bounds) {
  if (!bounds) return null;
  const { west, south, east, north } = bounds;
  // Round to 4 decimal places to reduce unique cache keys
  return `${west.toFixed(4)},${south.toFixed(4)},${east.toFixed(4)},${north.toFixed(4)}`;
}

/**
 * Fetch map GeoJSON for locations
 * @param {Object} options - Hook options
 * @param {Object} options.bounds - Viewport bounds { west, south, east, north }
 * @param {boolean} options.enabled - Whether to enable the query (default: true)
 * @returns {Object} Query result with GeoJSON and lookup map
 */
export function useMapMarkers({ bounds = null, enabled = true } = {}) {
  const bbox = boundsToBbox(bounds);

  const query = useQuery({
    // Include bbox in query key so different viewports get different cache entries
    queryKey: bbox ? ['mapGeoJSON', 'bbox', bbox] : ['mapGeoJSON'],
    queryFn: async () => {
      const params = bbox ? { bbox } : {};
      const response = await locationsApi.getMapGeoJSON(params);
      return response.data;
    },
    // Full dataset cached 30 min; viewport queries cached 5 min (user pans frequently)
    staleTime: bbox ? 5 * 60 * 1000 : 30 * 60 * 1000,
    // Keep previous data while new bbox query loads - prevents empty markerMap during loading
    placeholderData: keepPreviousData,
    enabled,
  });

  const geojson = query.data || EMPTY_GEOJSON;

  // O(1) lookup map for marker properties by ID
  // Maps feature.properties.id -> parsed properties (with images/type_metadata as objects)
  const markerMap = useMemo(() => {
    if (!geojson.features) return new Map();
    return new Map(geojson.features.map((f) => [f.properties.id, parseGeoJSONProperties(f.properties)]));
  }, [geojson]);

  // For backwards compatibility, expose markers array
  // (some components may still use markers.length, etc.)
  const markers = useMemo(() => {
    if (!geojson.features) return [];
    return geojson.features.map((f) => {
      const parsed = parseGeoJSONProperties(f.properties);
      return {
        ...parsed,
        // Coordinates are in properties now, but also keep from geometry for safety
        latitude: parsed.latitude ?? f.geometry.coordinates[1],
        longitude: parsed.longitude ?? f.geometry.coordinates[0],
      };
    });
  }, [geojson]);

  return {
    geojson, // GeoJSON FeatureCollection ready for Mapbox
    markers, // Backwards compatible markers array
    markerMap, // Use markerMap.get(id) for O(1) lookup
    isLoading: query.isLoading,
    isError: query.isError,
    error: query.error,
    refetch: query.refetch,
  };
}

export default useMapMarkers;
